{
  "version": "2.103.1-0",
  "grid": {
    "layers": { "Default layer": { "name": "Default layer" } },
    "xWidth": 10,
    "yHeight": 10
  },
  "modules": [
    {
      "url": "modules/types/client_interaction/code_executor/",
      "configuration": {
        "sections": {},
        "groups": {
          "group": [
            {
              "display": [["editor", "buttons"]],
              "execOnLoad": [[]],
              "asyncAwait": [["top"]],
              "script": [
                "const createContours = API.cache('createContours');\n\nlet zoomPos = API.cache('currentZoomPos');\nlet zoomNeg = API.cache('currentZoomNeg');\n\nif(this.action.name === 'wheelPos') {\n    zoomPos += Math.sign(this.action.value);\n} else {\n    zoomNeg += Math.sign(this.action.value);\n}\n\ncreateContours(zoomPos, zoomNeg);\n\nAPI.cache('currentZoomPos', zoomPos);\nAPI.cache('currentZoomNeg', zoomNeg);"
              ]
            }
          ],
          "libs": [[{}]],
          "buttons": [
            [
              {
                "name": "button1",
                "label": "Execute",
                "hide": [],
                "disable": []
              }
            ]
          ]
        }
      },
      "layers": {
        "Default layer": {
          "position": { "left": 0, "top": 0 },
          "size": { "width": 45, "height": 27 },
          "zIndex": 0,
          "display": true,
          "title": "",
          "bgColor": [255, 255, 255, 0],
          "wrapper": true,
          "created": true,
          "name": "Default layer"
        }
      },
      "id": 1,
      "vars_in": [{}],
      "actions_in": [
        { "rel": "execute", "name": "wheelPos" },
        { "rel": "execute", "name": "wheelNeg" }
      ],
      "vars_out": [{ "jpath": [] }],
      "actions_out": [{ "jpath": [] }],
      "toolbar": {
        "custom": [
          [
            {
              "title": "",
              "icon": "",
              "action": "",
              "position": "begin",
              "color": [100, 100, 100, 1]
            }
          ]
        ],
        "common": [{ "toolbar": [["Open Preferences"]] }]
      },
      "css": [{ "fontSize": [""], "fontFamily": [""] }],
      "title": ""
    },
    {
      "url": "modules/types/client_interaction/code_executor/",
      "configuration": {
        "sections": {},
        "groups": {
          "group": [
            {
              "display": [["editor", "buttons"]],
              "execOnLoad": [[]],
              "asyncAwait": [["top"]],
              "script": [
                "const Conrec = API.cache('conrec-lib');\n\nconst req = await fetch('../testcase/data/spectra2D/hmbc.jdx')\nconst jcamp = await req.text();\n\nconst parsed = await Converter.convert(jcamp, {\n    noContour: true,\n    xy: true\n})\n\nconst minMax = parsed.minMax;\n// todo bug in JCAMPCONVERTER!\nif (minMax.minX > minMax.maxX) {\n    const tmp = minMax.minX;\n    minMax.minX = minMax.maxX;\n    minMax.maxX = tmp;\n}\nif (minMax.minY > minMax.maxY) {\n    const tmp = minMax.minY;\n    minMax.minY = minMax.maxY;\n    minMax.maxY = tmp;\n}\nconst xs = getRange(minMax.minY, minMax.maxY, minMax.z.length);\nconst ys = getRange(minMax.minX, minMax.maxX, minMax.z[0].length);\nconst conrec = new Conrec(minMax.z, {xs, ys});\n\nconst firstLine = minMax.z[0].map(Math.abs);\nfirstLine.sort((a,b) => a-b);\nconst median = 2 * firstLine[Math.floor(firstLine.length / 2)];\n\nAPI.cache('createContours', createContours);\n\ncreateContours(0, 0);\n\nfunction createContours(zoomPos, zoomNeg) {\n    const positive = getContours(zoomPos, false);\n    const negative = getContours(zoomNeg, true);\n    const chart = {\n        data: [\n            {\n                type: 'contour',\n                contourLines: positive\n            },\n            {\n                type: 'contour',\n                contourLines: negative\n            }\n        ]\n    }\n    API.createData('chart', chart)\n}\n\nfunction getContours(zoomLevel, negative = false) {\n    const max = Math.max(Math.abs(minMax.maxZ), Math.abs(minMax.minZ));\n    let range;\n    if (negative) {\n        range = getRange(-max * 20 / 100, -median * 4 * Math.pow(2, zoomLevel), 10, 2);\n    } else {\n        range = getRange(median * 4 * Math.pow(2, zoomLevel), max * 20 / 100, 10, 2);\n    }\n    \n    const contours = conrec.drawContour({\n        levels: range,\n        timeout: 1000\n    });\n    return {\n        minX: minMax.minY,\n        maxX: minMax.maxY,\n        minY: minMax.minX,\n        maxY: minMax.maxX,\n        segments: contours\n    };\n}\n\nfunction getRange(min, max, length, exp) {\n    if (exp) {\n        var factors = new Array(length);\n        factors[0] = 0;\n        for (var i = 1; i < length; i++) {\n            factors[i] = factors[i - 1] + (exp - 1) / Math.pow(exp, i);\n        }\n        const lastFactor = factors[i - 1];\n\n        var result = new Array(length);\n        for (var i = 0; i < length; i++) {\n            result[i] = (max - min) * (1 - factors[i] / lastFactor) + min;\n        }\n        return result;\n    } else {\n        const step = (max - min) / (length - 1);\n        return range(min, max + step, step);\n    }\n}\n\nfunction range(from, to, step) {\n  const result = [];\n  for (let i = from; i < to; i += step) result.push(i);\n  return result;\n}\n"
              ]
            }
          ],
          "libs": [[{ "lib": "jcampconverter", "alias": "Converter" }]],
          "buttons": [
            [
              {
                "name": "button1",
                "label": "Execute",
                "hide": [],
                "disable": []
              }
            ]
          ]
        }
      },
      "layers": {
        "Default layer": {
          "position": { "left": 0, "top": 28 },
          "size": { "width": 45, "height": 27 },
          "zIndex": 0,
          "display": true,
          "title": "",
          "bgColor": [255, 255, 255, 0],
          "wrapper": true,
          "created": true,
          "name": "Default layer"
        }
      },
      "id": 2,
      "vars_in": [{}],
      "actions_in": [{ "rel": "execute", "name": "start" }],
      "vars_out": [{ "jpath": [] }],
      "actions_out": [{ "jpath": [] }],
      "toolbar": {
        "custom": [
          [
            {
              "title": "",
              "icon": "",
              "action": "",
              "position": "begin",
              "color": [100, 100, 100, 1]
            }
          ]
        ],
        "common": [{ "toolbar": [["Open Preferences"]] }]
      },
      "css": [{ "fontSize": [""], "fontFamily": [""] }],
      "title": ""
    },
    {
      "url": "modules/types/client_interaction/code_executor/",
      "configuration": {
        "sections": {},
        "groups": {
          "group": [
            {
              "display": [["editor", "buttons"]],
              "execOnLoad": [["yes"]],
              "asyncAwait": [["top"]],
              "script": [
                "'use strict';\r\n\r\n// https://github.com/jasondavies/conrec.js\r\n\r\n/**\r\n * Copyright (c) 2010, Jason Davies.\r\n *\r\n * All rights reserved.  This code is based on Bradley White's Java version,\r\n * which is in turn based on Nicholas Yue's C++ version, which in turn is based\r\n * on Paul D. Bourke's original Fortran version.  See below for the respective\r\n * copyright notices.\r\n *\r\n * See http://local.wasp.uwa.edu.au/~pbourke/papers/conrec/ for the original\r\n * paper by Paul D. Bourke.\r\n *\r\n * The vector conversion code is based on http://apptree.net/conrec.htm by\r\n * Graham Cox.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of the <organization> nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/*\r\n * Copyright (c) 1996-1997 Nicholas Yue\r\n *\r\n * This software is copyrighted by Nicholas Yue. This code is based on Paul D.\r\n * Bourke's CONREC.F routine.\r\n *\r\n * The authors hereby grant permission to use, copy, and distribute this\r\n * software and its documentation for any purpose, provided that existing\r\n * copyright notices are retained in all copies and that this notice is\r\n * included verbatim in any distributions. Additionally, the authors grant\r\n * permission to modify this software and its documentation for any purpose,\r\n * provided that such modifications are not distributed without the explicit\r\n * consent of the authors and that existing copyright notices are retained in\r\n * all copies. Some of the algorithms implemented by this software are\r\n * patented, observe all applicable patent law.\r\n *\r\n * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,\r\n * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS\r\n * PROVIDED ON AN \"AS IS\" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO\r\n * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\r\n * MODIFICATIONS.\r\n */\r\n\r\nconst EPSILON = Number.EPSILON;\r\nconst MINUSEPSILON = 0 - EPSILON;\r\n\r\n/**\r\n * Implements CONREC.\r\n * @private\r\n * @param {function} drawContour function for drawing contour.  Defaults to a\r\n *                               custom \"contour builder\", which populates the\r\n *                               contours property.\r\n */\r\nclass ConrecLib {\r\n  constructor(drawContour, timeout) {\r\n    this.drawContour = drawContour;\r\n    this.h = new Array(5);\r\n    this.sh = new Array(5);\r\n    this.xh = new Array(5);\r\n    this.yh = new Array(5);\r\n    this.timeout = timeout;\r\n  }\r\n  /**\r\n   * contour is a contouring subroutine for rectangularily spaced data\r\n   *\r\n   * It emits calls to a line drawing subroutine supplied by the user which\r\n   * draws a contour map corresponding to real*4data on a randomly spaced\r\n   * rectangular grid. The coordinates emitted are in the same units given in\r\n   * the x() and y() arrays.\r\n   *\r\n   * Any number of contour levels may be specified but they must be in order of\r\n   * increasing value.\r\n   *\r\n   * @private\r\n   * @param {number[][]} d - matrix of data to contour\r\n   * @param {number} ilb,iub,jlb,jub - index bounds of data matrix\r\n   *\r\n   *             The following two, one dimensional arrays (x and y) contain\r\n   *             the horizontal and vertical coordinates of each sample points.\r\n   * @param {number[]} x  - data matrix column coordinates\r\n   * @param {number[]} y  - data matrix row coordinates\r\n   * @param {number} nc   - number of contour levels\r\n   * @param {number[]} z  - contour levels in increasing order.\r\n   */\r\n  contour(d, ilb, iub, jlb, jub, x, y, nc, z) {\r\n    var h = this.h;\r\n    var sh = this.sh;\r\n    var xh = this.xh;\r\n    var yh = this.yh;\r\n    var drawContour = this.drawContour;\r\n    var timeout = this.timeout;\r\n    var start = Date.now();\r\n    /** private */\r\n    function xsect(p1, p2) {\r\n      return (h[p2] * xh[p1] - h[p1] * xh[p2]) / (h[p2] - h[p1]);\r\n    }\r\n    function ysect(p1, p2) {\r\n      return (h[p2] * yh[p1] - h[p1] * yh[p2]) / (h[p2] - h[p1]);\r\n    }\r\n    var m1;\r\n    var m2;\r\n    var m3;\r\n    var case_value;\r\n    var dmin;\r\n    var dmax;\r\n    var x1 = 0.0;\r\n    var x2 = 0.0;\r\n    var y1 = 0.0;\r\n    var y2 = 0.0;\r\n    // The indexing of im and jm should be noted as it has to start from zero\r\n    // unlike the fortran counter part\r\n    var im = [0, 1, 1, 0];\r\n    var jm = [0, 0, 1, 1];\r\n    // Note that castab is arranged differently from the FORTRAN code because\r\n    // Fortran and C/C++ arrays are transposed of each other, in this case\r\n    // it is more tricky as castab is in 3 dimensions\r\n    var castab = [\r\n      [[0, 0, 8], [0, 2, 5], [7, 6, 9]],\r\n      [[0, 3, 4], [1, 3, 1], [4, 3, 0]],\r\n      [[9, 6, 7], [5, 2, 0], [8, 0, 0]]\r\n    ];\r\n    for (var j = jub - 1; j >= jlb; j--) {\r\n      if (timeout && Date.now() - start > timeout) {\r\n        throw new Error(\r\n          `timeout: contour generation could not finish in less than ${timeout}ms`\r\n        );\r\n      }\r\n      for (var i = ilb; i <= iub - 1; i++) {\r\n        var temp1, temp2;\r\n        temp1 = Math.min(d[i][j], d[i][j + 1]);\r\n        temp2 = Math.min(d[i + 1][j], d[i + 1][j + 1]);\r\n        dmin = Math.min(temp1, temp2);\r\n        temp1 = Math.max(d[i][j], d[i][j + 1]);\r\n        temp2 = Math.max(d[i + 1][j], d[i + 1][j + 1]);\r\n        dmax = Math.max(temp1, temp2);\r\n        if (dmax >= z[0] && dmin <= z[nc - 1]) {\r\n          for (var k = 0; k < nc; k++) {\r\n            if (z[k] >= dmin && z[k] <= dmax) {\r\n              for (var m = 4; m >= 0; m--) {\r\n                if (m > 0) {\r\n                  // The indexing of im and jm should be noted as it has to\r\n                  // start from zero\r\n                  h[m] = d[i + im[m - 1]][j + jm[m - 1]] - z[k];\r\n                  xh[m] = x[i + im[m - 1]];\r\n                  yh[m] = y[j + jm[m - 1]];\r\n                } else {\r\n                  h[0] = 0.25 * (h[1] + h[2] + h[3] + h[4]);\r\n                  xh[0] = 0.5 * (x[i] + x[i + 1]);\r\n                  yh[0] = 0.5 * (y[j] + y[j + 1]);\r\n                }\r\n                if (h[m] > EPSILON) {\r\n                  sh[m] = 1;\r\n                } else if (h[m] < MINUSEPSILON) {\r\n                  sh[m] = -1;\r\n                } else {\r\n                  sh[m] = 0;\r\n                }\r\n              }\r\n              //\r\n              // Note: at this stage the relative heights of the corners and the\r\n              // centre are in the h array, and the corresponding coordinates are\r\n              // in the xh and yh arrays. The centre of the box is indexed by 0\r\n              // and the 4 corners by 1 to 4 as shown below.\r\n              // Each triangle is then indexed by the parameter m, and the 3\r\n              // vertices of each triangle are indexed by parameters m1,m2,and\r\n              // m3.\r\n              // It is assumed that the centre of the box is always vertex 2\r\n              // though this isimportant only when all 3 vertices lie exactly on\r\n              // the same contour level, in which case only the side of the box\r\n              // is drawn.\r\n              //\r\n              //\r\n              //      vertex 4 +-------------------+ vertex 3\r\n              //               | \\               / |\r\n              //               |   \\    m-3    /   |\r\n              //               |     \\       /     |\r\n              //               |       \\   /       |\r\n              //               |  m=2    X   m=2   |       the centre is vertex 0\r\n              //               |       /   \\       |\r\n              //               |     /       \\     |\r\n              //               |   /    m=1    \\   |\r\n              //               | /               \\ |\r\n              //      vertex 1 +-------------------+ vertex 2\r\n              //\r\n              //\r\n              //\r\n              //               Scan each triangle in the box\r\n              //\r\n              for (m = 1; m <= 4; m++) {\r\n                m1 = m;\r\n                m2 = 0;\r\n                if (m != 4) {\r\n                  m3 = m + 1;\r\n                } else {\r\n                  m3 = 1;\r\n                }\r\n                case_value = castab[sh[m1] + 1][sh[m2] + 1][sh[m3] + 1];\r\n                if (case_value != 0) {\r\n                  switch (case_value) {\r\n                    case 1: // Line between vertices 1 and 2\r\n                      x1 = xh[m1];\r\n                      y1 = yh[m1];\r\n                      x2 = xh[m2];\r\n                      y2 = yh[m2];\r\n                      break;\r\n                    case 2: // Line between vertices 2 and 3\r\n                      x1 = xh[m2];\r\n                      y1 = yh[m2];\r\n                      x2 = xh[m3];\r\n                      y2 = yh[m3];\r\n                      break;\r\n                    case 3: // Line between vertices 3 and 1\r\n                      x1 = xh[m3];\r\n                      y1 = yh[m3];\r\n                      x2 = xh[m1];\r\n                      y2 = yh[m1];\r\n                      break;\r\n                    case 4: // Line between vertex 1 and side 2-3\r\n                      x1 = xh[m1];\r\n                      y1 = yh[m1];\r\n                      x2 = xsect(m2, m3);\r\n                      y2 = ysect(m2, m3);\r\n                      break;\r\n                    case 5: // Line between vertex 2 and side 3-1\r\n                      x1 = xh[m2];\r\n                      y1 = yh[m2];\r\n                      x2 = xsect(m3, m1);\r\n                      y2 = ysect(m3, m1);\r\n                      break;\r\n                    case 6: //  Line between vertex 3 and side 1-2\r\n                      x1 = xh[m3];\r\n                      y1 = yh[m3];\r\n                      x2 = xsect(m1, m2);\r\n                      y2 = ysect(m1, m2);\r\n                      break;\r\n                    case 7: // Line between sides 1-2 and 2-3\r\n                      x1 = xsect(m1, m2);\r\n                      y1 = ysect(m1, m2);\r\n                      x2 = xsect(m2, m3);\r\n                      y2 = ysect(m2, m3);\r\n                      break;\r\n                    case 8: // Line between sides 2-3 and 3-1\r\n                      x1 = xsect(m2, m3);\r\n                      y1 = ysect(m2, m3);\r\n                      x2 = xsect(m3, m1);\r\n                      y2 = ysect(m3, m1);\r\n                      break;\r\n                    case 9: // Line between sides 3-1 and 1-2\r\n                      x1 = xsect(m3, m1);\r\n                      y1 = ysect(m3, m1);\r\n                      x2 = xsect(m1, m2);\r\n                      y2 = ysect(m1, m2);\r\n                      break;\r\n                    default:\r\n                      break;\r\n                  }\r\n                  // Put your processing code here and comment out the printf\r\n                  // printf(\"%f %f %f %f %f\\n\",x1,y1,x2,y2,z[k]);\r\n                  drawContour(x1, y1, x2, y2, z[k], k);\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\nclass BasicContourDrawer {\r\n  constructor(levels) {\r\n    this.contour = new Array(levels.length);\r\n    for (var i = 0; i < levels.length; i++) {\r\n      this.contour[i] = {\r\n        zValue: levels[i],\r\n        lines: []\r\n      };\r\n    }\r\n  }\r\n\r\n  drawContour(x1, y1, x2, y2, z, k) {\r\n    this.contour[k].lines.push(x1, y1, x2, y2);\r\n  }\r\n\r\n  getContour() {\r\n    return this.contour;\r\n  }\r\n}\r\n\r\n// Based on the code from https://github.com/jasondavies/conrec.js\r\n/**\r\n * Copyright (c) 2010, Jason Davies.\r\n *\r\n * All rights reserved.  This code is based on Bradley White's Java version,\r\n * which is in turn based on Nicholas Yue's C++ version, which in turn is based\r\n * on Paul D. Bourke's original Fortran version.  See below for the respective\r\n * copyright notices.\r\n *\r\n * See http://local.wasp.uwa.edu.au/~pbourke/papers/conrec/ for the original\r\n * paper by Paul D. Bourke.\r\n *\r\n * The vector conversion code is based on http://apptree.net/conrec.htm by\r\n * Graham Cox.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of the <organization> nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n/*\r\n * Copyright (c) 1996-1997 Nicholas Yue\r\n *\r\n * This software is copyrighted by Nicholas Yue. This code is based on Paul D.\r\n * Bourke's CONREC.F routine.\r\n *\r\n * The authors hereby grant permission to use, copy, and distribute this\r\n * software and its documentation for any purpose, provided that existing\r\n * copyright notices are retained in all copies and that this notice is\r\n * included verbatim in any distributions. Additionally, the authors grant\r\n * permission to modify this software and its documentation for any purpose,\r\n * provided that such modifications are not distributed without the explicit\r\n * consent of the authors and that existing copyright notices are retained in\r\n * all copies. Some of the algorithms implemented by this software are\r\n * patented, observe all applicable patent law.\r\n *\r\n * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,\r\n * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS\r\n * PROVIDED ON AN \"AS IS\" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO\r\n * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\r\n * MODIFICATIONS.\r\n */\r\n// Based on the code from https://github.com/jasondavies/conrec.js\r\n/**\r\n * Copyright (c) 2010, Jason Davies.\r\n *\r\n * All rights reserved.  This code is based on Bradley White's Java version,\r\n * which is in turn based on Nicholas Yue's C++ version, which in turn is based\r\n * on Paul D. Bourke's original Fortran version.  See below for the respective\r\n * copyright notices.\r\n *\r\n * See http://local.wasp.uwa.edu.au/~pbourke/papers/conrec/ for the original\r\n * paper by Paul D. Bourke.\r\n *\r\n * The vector conversion code is based on http://apptree.net/conrec.htm by\r\n * Graham Cox.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are met:\r\n *     * Redistributions of source code must retain the above copyright\r\n *       notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above copyright\r\n *       notice, this list of conditions and the following disclaimer in the\r\n *       documentation and/or other materials provided with the distribution.\r\n *     * Neither the name of the <organization> nor the\r\n *       names of its contributors may be used to endorse or promote products\r\n *       derived from this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\r\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\r\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF\r\n * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n/*\r\n * Copyright (c) 1996-1997 Nicholas Yue\r\n *\r\n * This software is copyrighted by Nicholas Yue. This code is based on Paul D.\r\n * Bourke's CONREC.F routine.\r\n *\r\n * The authors hereby grant permission to use, copy, and distribute this\r\n * software and its documentation for any purpose, provided that existing\r\n * copyright notices are retained in all copies and that this notice is\r\n * included verbatim in any distributions. Additionally, the authors grant\r\n * permission to modify this software and its documentation for any purpose,\r\n * provided that such modifications are not distributed without the explicit\r\n * consent of the authors and that existing copyright notices are retained in\r\n * all copies. Some of the algorithms implemented by this software are\r\n * patented, observe all applicable patent law.\r\n *\r\n * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR\r\n * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT\r\n * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,\r\n * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n *\r\n * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,\r\n * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS\r\n * PROVIDED ON AN \"AS IS\" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO\r\n * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR\r\n * MODIFICATIONS.\r\n */\r\nclass ContourBuilder {\r\n  constructor(level) {\r\n    this.level = level;\r\n    this.s = null;\r\n    this.count = 0;\r\n  }\r\n  removeSeq(list) {\r\n    // if list is the first item, static ptr s is updated\r\n    if (list.prev) {\r\n      list.prev.next = list.next;\r\n    } else {\r\n      this.s = list.next;\r\n    }\r\n    if (list.next) {\r\n      list.next.prev = list.prev;\r\n    }\r\n    --this.count;\r\n  }\r\n  addSegment(a, b) {\r\n    var ss = this.s;\r\n    var ma = null;\r\n    var mb = null;\r\n    var prependA = false;\r\n    var prependB = false;\r\n    while (ss) {\r\n      if (ma === null) {\r\n        // no match for a yet\r\n        if (pointsEqual(a, ss.head.p)) {\r\n          ma = ss;\r\n          prependA = true;\r\n        } else if (pointsEqual(a, ss.tail.p)) {\r\n          ma = ss;\r\n        }\r\n      }\r\n      if (mb === null) {\r\n        // no match for b yet\r\n        if (pointsEqual(b, ss.head.p)) {\r\n          mb = ss;\r\n          prependB = true;\r\n        } else if (pointsEqual(b, ss.tail.p)) {\r\n          mb = ss;\r\n        }\r\n      }\r\n      // if we matched both no need to continue searching\r\n      if (mb !== null && ma !== null) {\r\n        break;\r\n      } else {\r\n        ss = ss.next;\r\n      }\r\n    }\r\n    // c is the case selector based on which of ma and/or mb are set\r\n    var c = (ma !== null ? 1 : 0) | (mb !== null ? 2 : 0);\r\n    var pp;\r\n    switch (c) {\r\n      case 0: {\r\n        // both unmatched, add as new sequence\r\n        var aa = { p: a, prev: null };\r\n        var bb = { p: b, next: null };\r\n        aa.next = bb;\r\n        bb.prev = aa;\r\n        // create sequence element and push onto head of main list. The order\r\n        // of items in this list is unimportant\r\n        ma = { head: aa, tail: bb, next: this.s, prev: null, closed: false };\r\n        if (this.s) {\r\n          this.s.prev = ma;\r\n        }\r\n        this.s = ma;\r\n        ++this.count; // not essential - tracks number of unmerged sequences\r\n        break;\r\n      }\r\n      case 1: {\r\n        // a matched, b did not - thus b extends sequence ma\r\n        pp = { p: b };\r\n        if (prependA) {\r\n          pp.next = ma.head;\r\n          pp.prev = null;\r\n          ma.head.prev = pp;\r\n          ma.head = pp;\r\n        } else {\r\n          pp.next = null;\r\n          pp.prev = ma.tail;\r\n          ma.tail.next = pp;\r\n          ma.tail = pp;\r\n        }\r\n        break;\r\n      }\r\n      case 2: {\r\n        // b matched, a did not - thus a extends sequence mb\r\n        pp = { p: a };\r\n        if (prependB) {\r\n          pp.next = mb.head;\r\n          pp.prev = null;\r\n          mb.head.prev = pp;\r\n          mb.head = pp;\r\n        } else {\r\n          pp.next = null;\r\n          pp.prev = mb.tail;\r\n          mb.tail.next = pp;\r\n          mb.tail = pp;\r\n        }\r\n        break;\r\n      }\r\n      case 3: {\r\n        // both matched, can merge sequences\r\n        // if the sequences are the same, do nothing, as we are simply closing this path (could set a flag)\r\n        if (ma === mb) {\r\n          pp = { p: ma.tail.p, next: ma.head, prev: null };\r\n          ma.head.prev = pp;\r\n          ma.head = pp;\r\n          ma.closed = true;\r\n          break;\r\n        }\r\n        // there are 4 ways the sequence pair can be joined. The current setting of prependA and\r\n        // prependB will tell us which type of join is needed. For head/head and tail/tail joins\r\n        // one sequence needs to be reversed\r\n        switch ((prependA ? 1 : 0) | (prependB ? 2 : 0)) {\r\n          case 0: // tail-tail\r\n            // reverse ma and append to mb\r\n            reverseList(ma);\r\n          // fall through to head/tail case\r\n          case 1: // head-tail\r\n            // ma is appended to mb and ma discarded\r\n            mb.tail.next = ma.head;\r\n            ma.head.prev = mb.tail;\r\n            mb.tail = ma.tail;\r\n            // discard ma sequence record\r\n            this.removeSeq(ma);\r\n            break;\r\n          case 3: // head-head\r\n            // reverse ma and append mb to it\r\n            reverseList(ma);\r\n          // fall through to tail/head case\r\n          case 2: // tail-head\r\n            // mb is appended to ma and mb is discarded\r\n            ma.tail.next = mb.head;\r\n            mb.head.prev = ma.tail;\r\n            ma.tail = mb.tail;\r\n            // discard mb sequence record\r\n            this.removeSeq(mb);\r\n            break;\r\n          default:\r\n            throw new Error('UNREACHABLE');\r\n        }\r\n        break;\r\n      }\r\n      default:\r\n        throw new Error('UNREACHABLE');\r\n    }\r\n  }\r\n}\r\n\r\nfunction pointsEqual(a, b) {\r\n  var x = a.x - b.x;\r\n  var y = a.y - b.y;\r\n  return x * x + y * y < Number.EPSILON;\r\n}\r\n\r\nfunction reverseList(list) {\r\n  var pp = list.head;\r\n  var temp;\r\n  while (pp) {\r\n    // swap prev/next pointers\r\n    temp = pp.next;\r\n    pp.next = pp.prev;\r\n    pp.prev = temp;\r\n\r\n    // continue through the list\r\n    pp = temp;\r\n  }\r\n\r\n  // swap head/tail pointers\r\n  temp = list.head;\r\n  list.head = list.tail;\r\n  list.tail = temp;\r\n}\r\n\r\n// Based on the code from https://github.com/jasondavies/conrec.js\r\n\r\nclass ShapeContourDrawer {\r\n  constructor(levels) {\r\n    this.contours = new Array(levels.length);\r\n    for (var i = 0; i < levels.length; i++) {\r\n      this.contours[i] = new ContourBuilder(levels[i]);\r\n    }\r\n  }\r\n\r\n  drawContour(x1, y1, x2, y2, z, k) {\r\n    this.contours[k].addSegment({ x: x1, y: y1 }, { x: x2, y: y2 });\r\n  }\r\n\r\n  getContour() {\r\n    var l = [];\r\n    var a = this.contours;\r\n    for (var k = 0; k < a.length; k++) {\r\n      var s = a[k].s;\r\n      var level = a[k].level;\r\n      while (s) {\r\n        var h = s.head;\r\n        var l2 = [];\r\n        l2.level = level;\r\n        l2.k = k;\r\n        while (h && h.p) {\r\n          l2.push(h.p);\r\n          h = h.next;\r\n        }\r\n        l.push(l2);\r\n        s = s.next;\r\n      }\r\n    }\r\n    return l;\r\n  }\r\n}\r\n\r\nconst defaultOptions = {\r\n  nbLevels: 10,\r\n  timeout: 0\r\n};\r\n\r\n/**\r\n *\r\n * @class Conrec\r\n * @param {number[][]} matrix\r\n * @param {number[]} [options.xs]\r\n * @param {number[]} [options.ys]\r\n */\r\nclass Conrec {\r\n  constructor(matrix, options = {}) {\r\n    this.matrix = matrix;\r\n    this.xLength = matrix.length;\r\n    this.yLength = matrix[0].length;\r\n    this.xs = options.xs ? options.xs : range(0, this.xLength, 1);\r\n    this.ys = options.ys ? options.ys : range(0, this.yLength, 1);\r\n    this.levels = new Map();\r\n    this.hasMinMax = false;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {number[]} [options.levels]\r\n   * @param {number} [options.nbLevels=10]\r\n   * @param {string} [options.contourDrawer='basic'] - 'basic' or 'shape'\r\n   * @param {number} [options.timeout=0]\r\n   * @return {any}\r\n   */\r\n  drawContour(options) {\r\n    options = Object.assign({}, defaultOptions, options);\r\n\r\n    var levels;\r\n    if (options.levels) {\r\n      levels = options.levels.slice();\r\n    } else {\r\n      this._computeMinMax();\r\n      const interval = (this.max - this.min) / (options.nbLevels - 1);\r\n      levels = range(this.min, this.max + interval, interval);\r\n    }\r\n    levels.sort((a, b) => a - b);\r\n\r\n    let contourDrawer = options.contourDrawer || 'basic';\r\n    if (typeof contourDrawer === 'string') {\r\n      if (contourDrawer === 'basic') {\r\n        contourDrawer = new BasicContourDrawer(levels);\r\n      } else if (contourDrawer === 'shape') {\r\n        contourDrawer = new ShapeContourDrawer(levels);\r\n      } else {\r\n        throw new Error(`unknown contour drawer: ${contourDrawer}`);\r\n      }\r\n    } else {\r\n      throw new TypeError('contourDrawer must be a string');\r\n    }\r\n\r\n    const conrec = new ConrecLib(\r\n      contourDrawer.drawContour.bind(contourDrawer),\r\n      options.timeout\r\n    );\r\n    conrec.contour(\r\n      this.matrix,\r\n      0,\r\n      this.xLength - 1,\r\n      0,\r\n      this.yLength - 1,\r\n      this.xs,\r\n      this.ys,\r\n      levels.length,\r\n      levels\r\n    );\r\n    return contourDrawer.getContour();\r\n  }\r\n\r\n  _computeMinMax() {\r\n    if (!this.hasMinMax) {\r\n      const r = minMax(this.matrix);\r\n      this.min = r.min;\r\n      this.max = r.max;\r\n      this.hasMinMax = true;\r\n    }\r\n  }\r\n}\r\n\r\nfunction range(from, to, step) {\r\n  const result = [];\r\n  for (let i = from; i < to; i += step) result.push(i);\r\n  return result;\r\n}\r\n\r\nfunction minMax(matrix) {\r\n  let min = Number.POSITIVE_INFINITY;\r\n  let max = Number.NEGATIVE_INFINITY;\r\n  for (let i = 0; i < matrix.length; i++) {\r\n    const row = matrix[i];\r\n    for (let j = 0; j < row.length; j++) {\r\n      if (row[j] < min) min = row[j];\r\n      if (row[j] > max) max = row[j];\r\n    }\r\n  }\r\n  return {\r\n    min,\r\n    max\r\n  };\r\n}\r\n\r\nAPI.cache('conrec-lib', Conrec);\r\nAPI.doAction('start')"
              ]
            }
          ],
          "libs": [[{}]],
          "buttons": [
            [
              {
                "name": "button1",
                "label": "Execute",
                "hide": [],
                "disable": []
              }
            ]
          ]
        }
      },
      "layers": {
        "Default layer": {
          "position": { "left": 0, "top": 56 },
          "size": { "width": 45, "height": 28 },
          "zIndex": 0,
          "display": true,
          "title": "",
          "bgColor": [255, 255, 255, 0],
          "wrapper": true,
          "created": true,
          "name": "Default layer"
        }
      },
      "id": 3,
      "vars_in": [{}],
      "actions_in": [{}],
      "vars_out": [{ "jpath": [] }],
      "actions_out": [{ "jpath": [] }],
      "toolbar": {
        "custom": [
          [
            {
              "title": "",
              "icon": "",
              "action": "",
              "position": "begin",
              "color": [100, 100, 100, 1]
            }
          ]
        ],
        "common": [{ "toolbar": [["Open Preferences"]] }]
      },
      "css": [{ "fontSize": [""], "fontFamily": [""] }],
      "title": ""
    },
    {
      "url": "modules/types/science/spectra/spectra_displayer/",
      "configuration": {
        "sections": {
          "graph": [
            {
              "sections": {},
              "groups": {
                "graph": [
                  {
                    "url": [""],
                    "zoom": ["none"],
                    "wheelAction": ["none"],
                    "wheelbaseline": [0],
                    "fullOut": ["both"],
                    "legend": [null],
                    "legendOptions": [["isSerieHideable", "isSerieSelectable"]],
                    "mouseTracking": [[]],
                    "selectScatter": [[]],
                    "independantYZoom": [[]]
                  }
                ]
              }
            }
          ],
          "axis": [
            {
              "sections": {},
              "groups": {
                "xAxis": [
                  {
                    "checkboxes": [["display"]],
                    "label": [""],
                    "beforeSpacing": ["0"],
                    "afterSpacing": [0],
                    "min": [""],
                    "max": [""],
                    "nbTicksPrimary": [5],
                    "axismodification": ["none"]
                  }
                ],
                "yAxis": [
                  {
                    "checkboxes": [["display"]],
                    "label": [""],
                    "beforeSpacing": ["0"],
                    "afterSpacing": [0],
                    "min": [""],
                    "max": [""],
                    "nbTicksPrimary": [5],
                    "fitToAxisOnFromTo": [[]]
                  }
                ]
              }
            }
          ],
          "series": [
            {
              "sections": {},
              "groups": {
                "series": [{ "overflow": [[]], "stackVerticalSpacing": [0] }]
              }
            }
          ],
          "variables": [
            {
              "sections": {},
              "groups": {
                "variables": [
                  [
                    {
                      "variable": "chart",
                      "axis": "0",
                      "adaptTo": "none",
                      "plotcolor": [1, 1, 255, 1],
                      "strokewidth": "1",
                      "strokestyle": "1",
                      "plotcontinuous": "continuous",
                      "peakpicking": [],
                      "markers": [],
                      "markerShape": "1",
                      "markerSize": 2,
                      "normalize": "none",
                      "optimizeSlots": [],
                      "tracking": []
                    }
                  ]
                ]
              }
            }
          ],
          "misc": [
            {
              "sections": {},
              "groups": { "misc": [{ "highlightOptions": ["{}"] }] }
            }
          ]
        },
        "groups": {}
      },
      "layers": {
        "Default layer": {
          "position": { "left": 46, "top": 0 },
          "size": { "width": 107, "height": 77 },
          "zIndex": 0,
          "display": true,
          "title": "",
          "bgColor": [255, 255, 255, 0],
          "wrapper": true,
          "created": true,
          "name": "Default layer"
        }
      },
      "id": 4,
      "vars_in": [{ "rel": "chart", "name": "chart" }],
      "actions_in": [{}],
      "vars_out": [{ "jpath": [] }],
      "actions_out": [
        {
          "event": "onMouseWheel",
          "rel": "wheelDelta",
          "jpath": [],
          "name": "wheelPos"
        },
        {
          "event": "onMouseWheelShift",
          "rel": "wheelDelta",
          "jpath": [],
          "name": "wheelNeg"
        }
      ],
      "toolbar": {
        "custom": [
          [
            {
              "title": "",
              "icon": "",
              "action": "",
              "position": "begin",
              "color": [100, 100, 100, 1]
            }
          ]
        ],
        "common": [{ "toolbar": [["Open Preferences"]] }]
      },
      "css": [{ "fontSize": [""], "fontFamily": [""] }],
      "title": ""
    }
  ],
  "variables": [{ "jpath": [""] }],
  "aliases": [{}],
  "configuration": { "title": "No title" },
  "actionscripts": [
    {
      "sections": {},
      "groups": { "action": [{ "name": [null], "script": [null] }] }
    }
  ],
  "init_script": [
    {
      "sections": {},
      "groups": {
        "general": [
          {
            "script": [
              "API.cache('currentZoomPos', 0)\nAPI.cache('currentZoomNeg', 0)"
            ]
          }
        ]
      }
    }
  ],
  "custom_filters": [
    {
      "sections": {
        "modules": [{ "sections": {}, "groups": { "modules": [[{}]] } }],
        "filtersLib": [{ "sections": {}, "groups": { "filters": [[{}]] } }],
        "filters": [
          {
            "sections": {},
            "groups": {
              "filter": [{ "name": [null], "script": [null] }],
              "libs": [[{}]]
            }
          }
        ]
      },
      "groups": {}
    }
  ],
  "actionfiles": [{ "sections": {}, "groups": { "action": [[{}]] } }]
}

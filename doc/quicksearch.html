<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"api.js.html":{"id":"api.js.html","title":"Source: api.js","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Source: api.js 'use strict'; /** * Main visualizer API * @module src/util/api */ define([ './cache', './datatraversing', './actionmanager', './util', './versioning', './config', 'src/main/variables', 'src/main/datas', 'lodash', 'src/main/grid' ], function ( Cache, Traversing, ActionManager, Util, Versioning, Config, Variables, Data, _ ) { var variableFilters; var loadingSVG = Util.getLoadingAnimation(64, 'slateblue'); var loadingHtml = $('&lt;div&gt;', {id: 'ci-loading'}) .append(loadingSVG) .append($('&lt;div&gt;', {id: 'ci-loading-message', 'class': 'ci-loading-subtitle'})); var loading = {}; var loadingNumber = 0; function setHighlightId(id, value, senderId) { this.repositoryHighlights.set(id, value, null, senderId); } var exports = { getRepositoryData: function () { return this.repositoryData; }, setRepositoryData: function (repo) { this.repositoryData = repo; }, getRepositoryHighlights: function () { return this.repositoryHighlights; }, setRepositoryHighlights: function (repo) { this.repositoryHighlights = repo; }, getRepositoryActions: function () { return this.repositoryActions; }, setRepositoryActions: function (repo) { this.repositoryActions = repo; }, listenHighlight: function () { if (!arguments[0] || typeof arguments[0]._highlight == 'undefined') { return; } arguments[0] = arguments[0]._highlight; this.repositoryHighlights.listen.apply(this.repositoryHighlights, arguments); }, killHighlight: function () { this.repositoryHighlights.kill.apply(this.repositoryHighlights, arguments); }, highlightId: setHighlightId, getAllFilters: function () { return variableFilters; }, setAllFilters: function (filters) { variableFilters = _([filters, variableFilters]) .flatten() .filter(v=&gt; v &amp;&amp; v.name &amp;&amp; v.file) .uniq(v =&gt; v.file) .unshift({ file: '', name: 'No filter' }) .value(); }, isViewLocked: function () { return Versioning.isViewLocked(); }, viewLock: function () { return Versioning.viewLock(); }, getContextMenu: function () { return Config.contextMenu(); }, /* Extra functions used in filter testsuite. Allows compatibility of filters */ dev_fctCalled: function (fct) { }, dev_fctUncalled: function (fct) { }, dev_assert: function (family, script, value) { } }; /** * Check if a variable is defined * @param {string} varName - Name of the variable * @returns {boolean} */ exports.existVariable = function existVariable(varName) { return Variables.exist(varName); }; exports.existVar = exports.existVariable; /** * Set a variable using a jpath * @param {string} name - Name of the variable * @param {Variable} [sourceVariable] - Source variable. If set, the new variable will be created relative to its jpath * @param {string[]} jpath * @param {string} [filter] - Url of the filter to use with this variable */ exports.setVariable = function setVariable(name, sourceVariable, jpath, filter) { if (Array.isArray(sourceVariable)) { filter = jpath; jpath = sourceVariable; sourceVariable = null; } jpath = jpath || []; var jpathNewVar = (!sourceVariable) ? jpath : sourceVariable.getjPath().concat(jpath); return Variables.setVariable(name, jpathNewVar, false, filter); }; exports.setVar = exports.setVariable; /** * Create new data and set a variable to it * @param {string} name - Name of the variable * @param {*} data - Data to set * @param {string} [filter] - Url of the filter to use with this variable */ exports.createData = function createData(name, data, filter) { return exports.createDataJpath(name, data, [], filter); }; exports.createDataJpath = function createDataJpath(name, data, jpath, filter) { data = Data.check(Data.resurrect(data), true); if (data &amp;&amp; data.trace) { return data.trace(jpath) .then(data =&gt; Variables.setVariable(name, false, data, filter)); } else { return Variables.setVariable(name, false, data, filter); } }; /** * Get a variable by name * @param {string} name - Name of the variable * @returns {Variable} */ exports.getVariable = function getVariable(name) { return Variables.getVariable(name); }; exports.getVar = exports.getVariable; /** * Get the DataObject associated to a variable * @param {string} varName - Name of the variable * @returns {*} - DataObject or undefined */ exports.getData = function getData(varName) { return exports.getVariable(varName).getData(); }; /** * Change the state of a highlight * @param {object|array} element - Object with a _highlight property or array of highlight IDs * @param {boolean} onOff */ exports.setHighlight = function setHighlight(element, onOff) { if (!element) return; if (Array.isArray(element)) { element = {_highlight: element}; } if (typeof element._highlight == 'undefined') { return; } this.repositoryHighlights.set(element._highlight, onOff); }; exports.highlight = exports.setHighlight; /** * Set a loading message or change the value of an existing message * @param {string} id - ID of the message * @param {string} [message] - Message content (default: value of the ID) */ exports.loading = function setLoading(id, message) { if (!message) { message = id; } if (loadingNumber == 0) { $('#ci-visualizer').append(loadingHtml); } if (!loading[id]) { loading[id] = $('&lt;div&gt;' + message + '&lt;/div&gt;'); loadingNumber++; $('#ci-loading-message').append(loading[id]); } else { loading[id].html(message); } }; /** * Remove a loading message * @param {string} id - ID of the message */ exports.stopLoading = function stopLoading(id) { if (loading[id]) { loadingNumber--; loading[id].detach(); loading[id] = null; if (loadingNumber == 0) { loadingHtml.detach(); } } }; /** * Send an action to all modules and global action scripts * @param {string} name - Action name * @param {*} [value] - Action value */ exports.doAction = function doAction(name, value) { if (Data.isSpecialObject(value)) { value = value.get(); } this.repositoryActions.set(name, value); ActionManager.execute(name, value); }; /** * @deprecated * Execute a global visualizer action. This is deprecated. Use API.doAction instead. * @param {string} name - Action name * @param {*} value - Action value */ exports.executeAction = Util.deprecate(function executeAction(name, value) { ActionManager.execute(name, value); }, 'API.doAction is the recommended method.'); /** * Cache a value in memory or retrieve it. The value can be retrieved anywhere API is available * @param {string} name - Name of the cached value * @param {*} [value] - New value to set * @returns {*} The cached value or undefined if used as a setter */ exports.cache = function cacheHandler(name, value) { if (arguments.length === 1) { return Cache.get(name); } else { Cache.set(name, value); } }; /** * Set the cache to an empty object */ exports.cache.clear = function clearCache() { return Cache.clear(); }; exports.getLayerNames = function () { return require('src/main/grid').getLayerNames(); }; exports.switchToLayer = function (name) { return require('src/main/grid').switchToLayer(name); }; exports.getActiveLayerName = function () { return require('src/main/grid').getActiveLayerName(); }; exports.preventUnload = function (message) { window.onbeforeunload = function () { return message; }; }; exports.clearPreventUnload = function () { window.onbeforeunload = null; }; return exports; }); Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "},"color.js.html":{"id":"color.js.html","title":"Source: color.js","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Source: color.js 'use strict'; /** * Color manipulation * @module src/util/color */ define(function () { var exports = {}; exports.hex2rgb = function hex2rgb(hex) { var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex); return result ? [ parseInt(result[1], 16), parseInt(result[2], 16), parseInt(result[3], 16) ] : [0, 0, 0]; }; exports.array2rgba = function (arr) { if (!Array.isArray(arr)) return; if (arr.length === 3) { return 'rgba(' + arr[0] + ',' + arr[1] + ',' + arr[2] + ',1)'; } else if (arr.length === 4) { return 'rgba(' + arr[0] + ',' + arr[1] + ',' + arr[2] + ',' + arr[3] + ')'; } else { return 'rgba(0,0,0,1)'; } }; exports.rgb2hex = function rgb2hex(r, g, b) { if (arguments.length === 1) { var x = r.match(/rgba?\\(([^\\(]*)\\)/, 'i'); if (!x) return null; var rgb = x[1].split(','); if (rgb.length &gt;= 3) { r = +rgb[0]; g = +rgb[1]; b = +rgb[2]; } } return '#' + ((1 &lt;&lt; 24) + (r &lt;&lt; 16) + (g &lt;&lt; 8) + b).toString(16).slice(1); }; exports.hue2rgb = function hue2rgb(p, q, t) { if (t &lt; 0) t += 1; if (t &gt; 1) t -= 1; if (t &lt; 1 / 6) return p + (q - p) * 6 * t; if (t &lt; 1 / 2) return q; if (t &lt; 2 / 3) return p + (q - p) * (2 / 3 - t) * 6; return p; }; exports.hsl2rgb = function hsl2rgb(h, s, l) { var m1, m2, hue, r, g, b; s /= 100; l /= 100; if (s === 0) r = g = b = (l * 255); else { if (l &lt;= 0.5) m2 = l * (s + 1); else m2 = l + s - l * s; m1 = l * 2 - m2; hue = h / 360; r = exports.hue2rgb(m1, m2, hue + 1 / 3); g = exports.hue2rgb(m1, m2, hue); b = exports.hue2rgb(m1, m2, hue - 1 / 3); } return {r: r, g: g, b: b}; }; exports.getDistinctColors = function getDistinctColors(numColors) { var colors = new Array(numColors); var j = 0; for (var i = 0; i &lt; 360; i += 360 / numColors) { j++; var color = exports.hsl2rgb(i, 100, 30 + j % 4 * 15); colors[j - 1] = [Math.round(color.r * 255), Math.round(color.g * 255), Math.round(color.b * 255)]; } return colors; }; exports.getDistinctColorsAsString = function getDistinctColorsAsString(numColors) { var colors = exports.getDistinctColors(numColors); var colorsString = new Array(numColors); for (var i = 0; i &lt; numColors; i++) { colorsString[i] = exports.getColor(colors[i]); } return colorsString; }; exports.getNextColorRGB = function getNextColorRGB(colorNumber, numColors) { return this.getDistinctColors(numColors)[colorNumber]; }; exports.getColor = function getColor(color) { if (Array.isArray(color)) { if (color.length &gt;= 3) { for (var i = 0; i &lt; 3; i++) color[i] = Math.round(color[i]); } switch (color.length) { case 3: return 'rgb(' + color.join(',') + ')'; case 4: return 'rgba(' + color.join(',') + ')'; } } else if (typeof(color) == 'object') { return 'rgb(' + Math.round(color.r * 255) + ', ' + Math.round(color.g * 255) + ', ' + Math.round(color.b * 255) + ')'; } return color; }; exports.getBrightness = function (color) { // from http://www.w3.org/WAI/ER/WD-AERT/#color-contrast return ((color[0] / 255 * 299) + (color[1] / 255 * 587) + (color[2] / 255 * 114)) / (color[3] || 1); }; return exports; }); Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "},"couchdbAttachments.js.html":{"id":"couchdbAttachments.js.html","title":"Source: couchdbAttachments.js","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Source: couchdbAttachments.js 'use strict'; // Mini-library to manage couchdb attachments // - Get and upload attachments just by their name // - Cache already downloaded attachments define([ 'src/util/versioning', 'superagent', 'src/util/util' ], function (Versioning, superagent, util) { var base64DataUrlReg = /^data:([a-z]+\\/[a-z]+)?;base64,/; function dataURLtoBase64(data) { var pos; var l = Math.min(100, data.length); for (var i = 0; i &lt; l; i++) { if (data[i] === ';') { pos = i + 1; break; } } var t = data.slice(pos, pos + 7); if (pos &amp;&amp; t === 'base64,') { pos = pos + 7; return data.slice(pos); } else { throw new Error('Could not parse dataurl'); } } class CouchdbAttachments { /** * @param url Set the docUrl. If none specified, will attempt to use the viewURL to set the docURL * @constructor * @exports src/util/couchdbAttachments */ constructor() { // get the document url from the view url if (arguments.length === 0) { var viewUrl = Versioning.lastLoaded.view.url; if (!viewUrl) { throw new Error('couchdb attachments initialization failed: No view url'); } this.docUrl = viewUrl.replace(/\\/[^\\/]+$/, ''); } else { this.docUrl = arguments[0]; } } /** @return {object} attachments - An array with the attachments metadata @return {number} attachments[].name - The name of the resource @return {string} attachments[].content_type - Resource's mime-type @return {string} attachments[].digest - base64 md5 digest of the resource @return {number} attachments[].length - Length in bytes of the resource @return {number} attachments[].url - The url of the resource */ list(secondRound) { return Promise.resolve().then(() =&gt; { var hasAtt = this.lastDoc &amp;&amp; this.lastDoc._attachments; if (!this.lastDoc &amp;&amp; secondRound) { throw new Error('Unreachable'); } if (!hasAtt &amp;&amp; !secondRound) { return this.refresh().then(() =&gt; { return this.list(true); }); } else if (!hasAtt) { this.lastDoc._attachments = {}; } return this.attachmentsAsArray(this, this.lastDoc._attachments); }); } /** * Upload several attachments in one revision * @param {object[]} options * @param {string} options[].name - The name of the attachment * @param {string} options[].contentType - The contentType of the uploaded data * @param {string} options[].data - The attachment data to upload. If string, must be a valid base64 encoded dataURL. * @param {string} options[].content - The attachment data to upload. Alias of data. * @param {Blob|string} options[].file - The attachment data to upload. Alias of data. * @example * // With dataurl * cdb.inlineUploads([{ * name: 'example.png', * file: 'data:image/png;base64,ORK5CYII=' * }]); * // With Blob * cdb.inlineUploads([{ * name: 'example.txt', * file: new Blob(['example'], {content_type: 'text/plain'}); * }]); * // With data * cdb.inlineUploads([{ * name: 'example.txt', * contentType: 'text/plain', * data: 'example' * }]); * @returns {Promise.&lt;object&gt;} The new list of attachments */ inlineUploads(options) { var prom = this.list(); if (!options) return prom.then(() =&gt; { return attachmentsAsArray(this, this.lastAttachmentsResult); }); return prom.then(() =&gt; { if (!(Array.isArray(options))) { throw new TypeError('options must be an array'); } var prom = []; for (let i = 0; i &lt; options.length; i++) { let name = getName(options[i]); let item = options[i]; let data = item.data || item.file || item.content; if (typeof data === 'string') { if (item.encoding === 'base64') { this.lastDoc._attachments[name] = { content_type: item.contentType, data: data }; } else { let dataUrl = base64DataUrlReg.exec(data.slice(0, 64)); if (!dataUrl) { this.lastDoc._attachments[name] = { content_type: item.contentType, data: btoa(unescape(encodeURIComponent(data))) }; } else { this.lastDoc._attachments[name] = { content_type: item.contentType || dataUrl[1], data: data.slice(dataUrl[0].length) }; } } } else if (data instanceof Blob) { if (!item.contentType &amp;&amp; data.type) { item.contentType = data.type; } let p = new Promise((resolve, reject) =&gt; { let reader = new FileReader(); reader.onload = function (e) { return resolve({ item: item, base64data: dataURLtoBase64(e.target.result) }); }; reader.onerror = function () { return reject('Error while reading file'); }; reader.readAsDataURL(data); }); prom.push(p); } else { return Promise.reject(new Error('Item must have a valid data or file property')); } } return Promise.all(prom); }).then(toChange =&gt; { for (let i = 0; i &lt; toChange.length; i++) { const c = toChange[i]; this.lastDoc._attachments[getName(c.item)] = { content_type: c.item.contentType, data: c.base64data }; } return superagent .put(this.docUrl) .withCredentials() .set('Content-Type', 'application/json') .set('Accept', 'application/json') .send(this.lastDoc) .end(); }).then(() =&gt; this.refresh()); } /** * * @param {object} options * @param {string} options.name - Name of the attachment to upload * @param {string} options.filename - Alias for name * @param {string} options.contentType - Content-Type of the attachment to upload * @param {string|Blob} options.data - The attachment's content to upload * @param {string|Blob} options.file - The attachments's content to upload * @param {string|Blob} options.content - The attachments's content to upload * @returns {Promise.&lt;Object&gt;} The new list of attachments */ upload(options) { let data = options.data || options.file || options.content; return this.list().then(() =&gt; { if (!options) { throw new Error('Invalid arguments'); } let contentType = options.contentType; if (!contentType &amp;&amp; data instanceof Blob) { contentType = data.type; } else if (typeof data === 'string') { if (options.encoding === 'base64') { data = options.data; } else { let dataUrl = base64DataUrlReg.exec(data.slice(0, 64)); if (dataUrl) { data = util.b64toBlob(data.slice(dataUrl[0].length), dataUrl[1]); contentType = dataUrl[1]; } else { data = new Blob([data], {content_type: options.contentType}); } } } else if (!(data instanceof Blob)) { throw new Error('Data must be Blob or base64 dataUrl'); } if (!contentType) { throw new Error('Content-Type unresolved. Cannot upload document without content-type'); } return superagent .put(this.docUrl + '/' + getName(options)) .withCredentials() .query({rev: this.lastDoc._rev}) .set('Content-Type', contentType) .set('Accept', 'application/json') .send(data) .then(res =&gt; { if (res &amp;&amp; res.body &amp;&amp; res.body.rev) { this.lastDoc._rev = res.body.rev; } }); }).then(() =&gt; this.refresh()); } /** * Get the content of an attachment * @param name The name of the attachment to get * @return {Promise} The parsed content of the attachment */ get(name, options) { options = options || {}; return this.list().then(() =&gt; { const _att = this.lastDoc._attachments[name]; if (!_att) throw new Error('The attachment ' + name + ' does not exist'); const req = superagent.get(this.docUrl + '/' + name).withCredentials(); if (options.responseType) { req.responseType(options.responseType); } if (_att) req.set('Accept', this.lastDoc._attachments[name].content_type); return req.query({rev: this.lastDoc._rev}) .then(res =&gt; { if (options.raw) return res.text; else if (options.responseType === 'blob') return res.xhr.response; return res.body; }); }); } /** * Remove an attachment * @param name The name of the attachment to remove. * @returns {Promise.&lt;Object&gt;} The new list of attachments */ remove(name) { if (Array.isArray(name)) { return inlineRemove(this, name); } return this.list().then(() =&gt; { if (!this.lastDoc._attachments[name]) throw new Error('Cannot remove attachment, attachment does not exist.'); return superagent .del(this.docUrl + '/' + name) .withCredentials() .query({rev: this.lastDoc._rev}) .set('Accept', 'application/json') .then(res =&gt; { if (res &amp;&amp; res.body &amp;&amp; res.body.rev) { this.lastDoc._rev = res.body.rev; delete this.lastDoc._attachments[name]; return attachmentsAsArray(this, this.lastDoc._attachments); } else { throw new Error('Unexpected error when removing attachments'); } }); }); } /** * Refreshes the list of attachment from couchdb. * @returns {Promise.&lt;Object&gt;} attachments - The new list of attachments */ // Get documents with latest attachements' rev ids refresh() { return superagent .get(this.docUrl) .withCredentials() .set('Accept', 'application/json') .then(res =&gt; { this.lastDoc = res.body; return attachmentsAsArray(this, res.body._attachments); }); } /** * An alias for refresh * Refreshes the list of attachment from couchdb. * @returns {Promise.&lt;Object&gt;} attachments - The new list of attachments */ fetchList() { return this.refresh(); } attachmentsAsArray() { var r = []; var i = 0; for (var key in this.lastDoc._attachments) { r.push(this.lastDoc._attachments[key]); r[i].name = key; r[i].url = encodeURI(this.docUrl + '/' + key); i++; } this.lastAttachmentsResult = r; return r; } // This is an alternative strategy for storing multiple attachments in one revision // The problem with this is that it doesn't allow to change the contentType // (because Blobs are immutable) if the browser did not set it correctly or if // the user wants to manually change it will not work properly uploads1(files) { if (!Array.isArray(files)) { throw new Error('uploads expects an array as parameter'); } var req = superagent.post(this.docUrl).withCredentials(); for (var i = 0; i &lt; files.length; i++) { var file = files[i]; req.attach('_attachments', file, getName(file)); } req.field('_rev', this.lastDoc._rev); return req.end().then(res =&gt; { if (res.status !== 201) throw new Error('Error uploading attachments, couchdb returned status code ' + res.status); return this.refresh(); }); } } // Private function function inlineRemove(ctx, names) { return ctx.list().then(() =&gt; { if (!Array.isArray(names)) throw new TypeError('Argument should be an array'); if (names.length === 0) return ctx.list(); for (var i = 0; i &lt; names.length; i++) { delete ctx.lastDoc._attachments[names[i]]; } return superagent .put(ctx.docUrl) .withCredentials() .set('Content-Type', 'application/json') .set('Accept', 'application/json') .send(ctx.lastDoc) .then(res =&gt; { if (res &amp;&amp; res.body &amp;&amp; res.body.rev) { ctx.lastDoc._rev = res.body.rev; return attachmentsAsArray(ctx, ctx.lastDoc._attachments); } }); }).then(() =&gt; ctx.refresh()); } function attachmentsAsArray(ctx, att) { var r = []; var i = 0; for (var key in att) { r.push(att[key]); r[i].name = key; r[i].filename = key; r[i].url = encodeURI(ctx.docUrl + '/' + key); i++; } ctx.lastAttachmentsResult = r; return r; } function getName(options) { return options.name || options.filename; } return CouchdbAttachments; }); Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "},"ui.js.html":{"id":"ui.js.html","title":"Source: ui.js","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Source: ui.js 'use strict'; /** * Global ui methods * @module src/util/ui */ define([ 'src/util/util', 'src/util/debug', 'lodash', 'jquery', 'src/util/typerenderer', 'src/util/versioning', 'slickgrid', 'forms/button', 'src/util/couchshare', 'jquery-ui/dialog' ], function (Util, Debug, _, $, Renderer, Versioning, Slick, Button, Sharer) { var exports = {}; var $dialog; exports.showCode = function (opts) { var opts = Object.assign({ mode: 'json', content: '', width: 800, height: 600 }, opts); require(['ace/ace'], function (ace) { var id = Util.getNextUniqueId(true); exports.dialog($(`&lt;div style=&quot;width: 100%; height: 100%;&quot; id=&quot;${id}&quot;&gt;&lt;/div&gt;`), opts); var editor = ace.edit(id); var mode = './mode/' + opts.mode; editor.getSession().setMode(mode); editor.setValue(opts.content, -1); }); }; exports.enterValue = function (opts) { opts = opts || {}; const defaultOptions = { description: '', label: 'Enter a value', buttonLabel: 'Submit', validationMessage: 'What you entered is not valid', value: '' }; opts = Object.assign({}, defaultOptions, opts); return new Promise(function (resolve) { var div = $(`&lt;div&gt;${opts.description}&lt;div&gt;${opts.label}: &lt;/div&gt;&lt;/div&gt;`); var input = $(`&lt;input type=&quot;text&quot; value=&quot;${opts.value}&quot;/&gt;`).appendTo(div.find('div')).on('keypress', evt =&gt; { if (evt.keyCode === 13) done(); }); const done = () =&gt; { var value = input.val(); if (opts.validation &amp;&amp; typeof opts.validation === 'function') { if (!opts.validation(value)) { exports.showNotification(opts.validationMessage, 'error'); return; } } resolve(value); dialog.dialog('destroy'); }; var options = { buttons: {}, close: function () { resolve(); dialog.dialog('destroy'); } }; options.buttons[opts.buttonLabel] = done; var dialog = exports.dialog(div, options); }); }; exports.choose = function (list, options) { options = options || {}; options = _.defaults(options, { slick: {} }); var readyToAddItems; // Slick Rendering function waitFormatter() { return '...'; } function typeRenderer(cellNode, row, dataContext, colDef) { if (cellNode) { Renderer.render(cellNode, dataContext[colDef.field], colDef.rendererOptions); } } var _ready = new Promise(resolve =&gt; { readyToAddItems = resolve; }); // Display function updateHeader() { $header.html(` &lt;table&gt;&lt;tr&gt;&lt;td&gt; ${sources ? (sources + ' sources left') : 'Sources loaded.' + (failedSources ? (' (' + failedSources + ' failed)') : '')} &lt;/td&gt; &lt;td id=&quot;abc&quot;&gt; &lt;/td&gt;&lt;/tr&gt; `); var animCell = $($header.find('td')[1]); animCell.append(Util.getLoadingAnimation(16, 'blue')); if (!sources) { animCell.remove(); } } function addItems(arr) { return _ready.then(function (slick) { slick.data.beginUpdate(); for (var i = 0; i &lt; arr.length; i++) { slick.data.addItem(arr[i]); } slick.data.endUpdate(); slick.grid.invalidateAllRows(); slick.grid.render(); slick.grid.resizeCanvas(); sources--; updateHeader(); }); } // Default values var slickDefaultOptions = { editable: true, enableAddRow: false, enableTextSelectionOnCells: true, forceFitColumns: true, explicitInitialization: true, rowHeight: 20, enableAsyncPostRender: true }; var slickDefaultColumn = { formatter: waitFormatter, asyncPostRender: typeRenderer }; var grid, data, lastClickedId, buttons, arr, columns, sources, failedSources = 0, $header; var fromArray = Array.isArray(list); if (!options.asynchronous) { allProm = []; if (fromArray) { arr = list; } else { var keys = Object.keys(list); arr = new Array(keys.length); for (var i = 0; i &lt; arr.length; i++) { arr[i] = { key: keys[i], description: list[keys[i]] }; } } addItems(arr); } else if (fromArray) { sources = list.length; var allProm = new Array(list.length); for (var i = 0; i &lt; list.length; i++) { allProm[i] = list[i].promise.then(addItems).catch(function (e) { sources--; failedSources++; updateHeader(); }); } } else { throw new Error('Invalid arguments'); } var slickOptions = _.defaults(options.slick, slickDefaultOptions); if (options.columns) { columns = options.columns; } else { columns = [ { id: 'key', name: 'key', field: 'key' }, { id: 'description', name: 'description', field: 'description' } ]; } for (var i = 0; i &lt; columns.length; i++) { columns[i] = _.defaults(columns[i], slickDefaultColumn); } return new Promise(function (resolve, reject) { Util.loadCss('components/slickgrid/slick.grid.css').then(function () { var $dialog = $('&lt;div&gt;'); var $slick = $('&lt;div&gt;'); var $container = $('&lt;div&gt;').css('height', 410); Promise.all(allProm).then(() =&gt; { var len = data.getLength(); if (len === 1 &amp;&amp; options.autoSelect) { var id = data.mapRowsToIds([0])[0]; resolve(id); $dialog.dialog('close'); } }); if (options.noConfirmation) { buttons = {}; } else { buttons = { Cancel: function () { $(this).dialog('close'); }, Select: function () { resolve(lastClickedId); $(this).dialog('close'); } }; } exports.dialog($dialog, { noWrap: true, buttons: buttons, close: function () { resolve(); }, resize: function () { grid.resizeCanvas(); }, open: function () { var that = this; $container.addClass('flex-main-container'); $slick.addClass('flex-1'); $header = $('&lt;div&gt;'); $container.append($header); $container.append($slick); $dialog.append($container); data = new Slick.Data.DataView(); data.setItems([], options.idField || 'key'); grid = new Slick.Grid($slick, data, columns, slickOptions); grid.setSelectionModel(new Slick.RowSelectionModel()); grid.onClick.subscribe(function (e, args) { // Get id lastClickedId = data.mapRowsToIds([args.row])[0]; if (options.noConfirmation) { resolve(lastClickedId); $(that).dialog('close'); } }); grid.init(); readyToAddItems({ data, grid }); updateHeader(); }, closeOnEscape: false, width: 700, height: 500 }); }); }).then(function (result) { if (options.returnRow) { return data.getItemById(result); } else if (options.returnColumn) { return data.getItemById(result)[options.returnColumn]; } else { return result; } }); }; exports.confirm = function (html, okLabel, cancelLabel) { if (_.isUndefined(okLabel)) okLabel = 'Ok'; if (_.isUndefined(cancelLabel)) cancelLabel = 'Cancel'; return new Promise(function (resolve) { if (!$dialog) { $dialog = $('&lt;div/&gt;'); $('body').append($dialog); } if (html) { $dialog.html(html); } var options = { modal: true, buttons: {}, close: function () { resolve(false); }, width: 400 }; if (okLabel !== null &amp;&amp; okLabel !== '') options.buttons[okLabel] = function () { resolve(true); $(this).dialog('close'); }; if (cancelLabel !== null &amp;&amp; cancelLabel !== '') options.buttons[cancelLabel] = function () { resolve(false); $(this).dialog('close'); }; $dialog.dialog(options); }); }; var defaultDialogOptions = { appendTo: '#ci-visualizer', modal: true, autoDestroy: true, autoPosition: false, noHeader: false, noWrap: false }; exports.dialog = function (div, options) { if (typeof div === 'object' &amp;&amp; !div.jquery) { options = div; div = null; } options = $.extend({}, defaultDialogOptions, options); var $dialog; if (options.noWrap) { $dialog = $(div || '&lt;div&gt;'); } else { $dialog = $('&lt;div&gt;').html(div || ''); } if (options.autoDestroy &amp;&amp; !options.close) { options.close = function () { $(this).dialog('destroy'); }; } if (options.autoPosition) { options.position = { my: 'top+50', at: 'center top', of: '#ci-visualizer' }; } $dialog.dialog(options); if (options.noHeader) { $dialog.prev().remove(); } return $dialog; }; exports.copyToClipboard = function (str) { var strlen = str.length; var txtarea = $('&lt;textarea/&gt;').text(str).css({ width: 0, height: 0, position: 'fixed' }); $('body').append(txtarea); var txtdom = txtarea.get(0); txtdom.selectionStart = 0; txtdom.selectionEnd = strlen; txtdom.focus(); var success = document.execCommand('copy'); if (success) exports.showNotification('Copy success', 'success'); else exports.showNotification('Copy failure', 'error'); txtarea.remove(); }; exports.copyview = function () { var str = Versioning.getViewJSON(' '); var strlen = str.length; var txtarea = $('&lt;textarea/&gt;').text(str).css({ width: '100%', height: '95%' }); exports.dialog(txtarea, { width: '80%', height: $('#ci-visualizer').height() * 0.7 }); var txtdom = txtarea.get(0); txtdom.selectionStart = 0; txtdom.selectionEnd = strlen; txtdom.focus(); }; exports.copyData = function () { var str = Versioning.getDataJSON(' '); var strlen = str.length; var txtarea = $('&lt;textarea/&gt;').text(str).css({ width: '100%', height: '200px' }); exports.dialog(txtarea, {width: '80%'}); var txtdom = txtarea.get(0); txtdom.selectionStart = 0; txtdom.selectionEnd = strlen; txtdom.focus(); }; exports.pasteData = function () { var txtarea = $('&lt;textarea&gt;&lt;/textarea&gt;').css({ width: '100%', height: '200px' }), val, keys, btn = new Button('Paste', function () { try { val = JSON.parse(txtarea.val()); keys = Object.keys(val); for (var i = 0, ii = keys.length; i &lt; ii; i++) { if (keys[i].charAt(0) === '_') delete val[keys[i]]; } Versioning.setDataJSON(val); } catch (_) { // do nothing } div.dialog('close'); }); var div = exports.dialog(txtarea, {width: '80%'}).append(btn.render()); }; exports.pasteView = function () { var txtarea = $('&lt;textarea&gt;&lt;/textarea&gt;').css({ width: '100%', height: '200px' }), val, keys, btn = new Button('Paste', function () { try { val = JSON.parse(txtarea.val()); keys = Object.keys(val); for (var i = 0, ii = keys.length; i &lt; ii; i++) { if (keys[i].charAt(0) === '_') delete val[keys[i]]; } Versioning.setViewJSON(val); } catch (_) { // do nothing } div.dialog('close'); }); var div = exports.dialog(txtarea, {width: '80%'}).append(btn.render()); }; exports.feedback = function (options, shareOptions) { options = options || {}; shareOptions = shareOptions || {}; shareOptions = _.defaults(shareOptions, { couchUrl: 'http://visualizer.epfl.ch', database: 'x', tinyUrl: 'http://visualizer.epfl.ch/tiny' }); if (!options.disabled) { Sharer.share(shareOptions).then(function (tinyUrl) { var description = '\\n\\nTestcase: ' + tinyUrl + ' ([Original URL](' + document.location.href + '))'; var url = 'https://github.com/NPellet/visualizer/issues/new?body=' + encodeURIComponent(description); var win = window.open(url, '_blank'); win.focus(); }).catch(error =&gt; { exports.showNotification('Error with Feedback, maybe pop-up was blocked', 'error'); }); } }; exports.couchShare = function (options, dialogOptions) { var uniqid = Util.getNextUniqueId(); var dialog = $('&lt;div&gt;').html('&lt;h3&gt;Click the share button to make a snapshot of your view and generate a tiny URL&lt;/h3&gt;&lt;br&gt;').append( new Button('Share', function () { var that = this; if (!options.disabled) { Sharer.share(options).then(function (tinyUrl) { $('#' + uniqid).val(tinyUrl).focus().select(); that.disable(); }, function () { $('#' + uniqid).val('error'); }); } }, {color: 'blue'}).render() ).append( $('&lt;input type=&quot;text&quot; id=&quot;' + uniqid + '&quot; /&gt;').css('width', '400px') ); exports.dialog(dialog, dialogOptions); }; exports.showNotification = function () { var args = arguments; if (args[1] &amp;&amp; (typeof args[1] === 'string')) { args[1] = { className: args[1], autoHide: args[1] !== 'error' }; } else if (args[1] &amp;&amp; args[1].className === 'error') { args[1] = Object.assign({autoHide: false}, args[1]); } require(['notifyjs'], function () { $.notify.apply($.notify, args); }); }; exports.getSafeElement = function (el) { return exports.makeElementSafe('&lt;' + el + '&gt;'); }; exports.makeElementSafe = function (el) { return $(el).css({ width: '100%', height: '100%', margin: 0, padding: 0, border: 'none' }); }; return exports; }); Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "},"uploadUi.js.html":{"id":"uploadUi.js.html","title":"Source: uploadUi.js","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Source: uploadUi.js 'use strict'; /** * Global ui methods * @module src/util/ui */ define([ 'src/util/util', 'src/util/debug', 'src/util/ui', 'lodash', 'jquery', 'slickgrid', 'mime-types' ], function (Util, Debug, ui, _, $, Slick, mimeTypes) { function attachmentsFromCouch(data, options) { var r = new Array(data.length); for (var i = 0; i &lt; data.length; i++) { var d = data[i]; r[i] = { name: d.name, contentType: d.content_type, size: d.length, toDelete: false }; if (options.docUrl) { r[i].downloadUrl = options.docUrl + '/' + (d.name); } } return r; } var modes = { couchdb: attachmentsFromCouch, couch: attachmentsFromCouch }; var exports = {}; var cssLoaded = Promise.all([ Util.loadCss('components/slickgrid/slick.grid.css'), Util.loadCss('src/util/uploadUi.css') ]); var prefix = 'upload/'; function uploadDialog(data, options) { var mode = options.mode; if (data &amp;&amp; mode &amp;&amp; modes[mode]) { data = modes[mode](data, options); } var slickData = new Slick.Data.DataView(); data = data || []; slickData.setItems(data, 'name'); return cssLoaded .then(function () { return new Promise(function (resolve) { var slickOptions = { editable: true, enableAddRow: false, enableCellNavigation: true, autoEdit: true, enableTextSelectionOnCells: true, enableColumnReorder: true, forceFitColumns: true, multiColumnSort: true, asyncEditorLoading: true, asyncEditorLoadDelay: 30, enableAsyncPostRender: true, asyncPostRenderDelay: 0, rowHeight: 20 }; var columns = [ { id: 'name', name: 'name', field: 'name', sortable: false }, { id: 'contentType', name: 'contentType', field: 'contentType', editor: Slick.Editors.Text, sortable: false }, { id: 'size', name: 'size', field: 'size', sortable: false }, { id: 'toDelete', name: 'toDelete', field: 'toDelete', width: 40, editor: Slick.Editors.Checkbox, formatter: Slick.Formatters.Checkmark } ]; if (data[0] &amp;&amp; data[0].downloadUrl) { columns.push({ id: '__download_attachment__', name: 'Download', field: '__download_attachment__', sortable: false, width: 30, formatter: downloadFormatter }); } var $dialog = $('&lt;div class=&quot;upload-ui&quot;&gt;'); var $slick = $('&lt;div class=&quot;dropzone&quot;&gt;'); var $deleteAll = $('&lt;input type=&quot;checkbox&quot;&gt;Select/Unselect Delete&lt;/input&gt;'); $deleteAll.on('change', function () { var toSet = !!this.checked; data.forEach(function (d) { if (d.name !== 'view.json' || d.name === 'data.json' || d.name === 'meta.json') d.toDelete = toSet; }); grid.invalidate(); grid.render(); }); var grid; ui.dialog($dialog, { buttons: { Cancel: function () { $(this).dialog('close'); }, Upload: function () { var toUpload = _.filter(data, function (v) { return v.file || v.toDelete; }); resolve(toUpload); $(this).dialog('close'); } }, close: function () { resolve(false); }, resize: function () { grid.resizeCanvas(); }, open: function () { $dialog.append($slick); $dialog.append($deleteAll); grid = new Slick.Grid($slick, data, columns, slickOptions); }, closeOnEscape: true, width: 700, height: 500 }); var dragCount = 0; $dialog[0].addEventListener('dragenter', function (e) { e.preventDefault(); e.stopPropagation(); dragCount++; if (dragCount === 1) $slick.addClass('drop-over'); }); $dialog[0].addEventListener('dragleave', function (e) { e.preventDefault(); e.stopPropagation(); dragCount--; if (!dragCount) $slick.removeClass('drop-over'); }); $dialog[0].addEventListener('dragover', function (e) { e.preventDefault(); }); function addFile(file, name) { name = name || ''; var filePath = prefix + (name === '' ? file.name : name + '/' + file.name); var exists = _.find(data, function (v) { return v.name === filePath; }); if (exists) { exists.file = file; exists.color = 'orange'; } else { data.push({ name: filePath, file: file, contentType: file.type || mimeTypes.lookup(filePath) || 'application/octet-stream', size: file.size || 0, toDelete: false, color: 'green' }); } } function doFile(entry, name) { return new Promise(function (resolve) { entry.file(function (file) { addFile(file, name); resolve(file); }); }); } function traverseEntries(entry, name) { name = name || ''; if (entry.isDirectory) { return Promise.resolve().then(function () { var dirReader = entry.createReader(); return new Promise(function (resolve, reject) { dirReader.readEntries(function (fileEntries) { var prom = []; for (var i = 0; i &lt; fileEntries.length; i++) { var fileEntry = fileEntries[i]; if (fileEntry.isFile) { prom.push(doFile(fileEntry, name)); } else if (fileEntry.isDirectory) { prom.push(traverseEntries(fileEntry, name + '/' + fileEntry.name)); } } return resolve(Promise.all(prom)); }); }); }); } else { return doFile(entry); } } // Get file data on drop $dialog[0].addEventListener('drop', function (e) { e.stopPropagation(); e.preventDefault(); dragCount = 0; $dialog.removeClass('drop-over'); var prom = []; for (var i = 0; i &lt; e.dataTransfer.items.length; i++) { var entry = e.dataTransfer.items[i].webkitGetAsEntry(); prom.push(traverseEntries(entry, entry.name)); } Promise.all(prom).then(function () { grid.updateRowCount(); grid.render(); grid.autosizeColumns(); }); }); }); }); } function downloadFormatter(row, cell, value, coldef, dataContext) { var name = dataContext.name.replace(/^.*\\//, ''); return `&lt;div style=&quot;width:100%; height: 100%;&quot;&gt;&lt;a href=&quot;${dataContext.downloadUrl}&quot; download=&quot;${name}&quot; class=&quot;download-attachment&quot;&gt;&lt;i class=&quot;centered-icon fa fa-download&quot;&gt;&lt;/i&gt;&lt;/a&gt;&lt;/div&gt;`; } exports.uploadDialog = uploadDialog; return exports; }); Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "},"util.js.html":{"id":"util.js.html","title":"Source: util.js","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Source: util.js 'use strict'; /** * Global utility methods * @module src/util/util */ define(['src/util/debug', 'src/util/color', 'lodash', 'src/data/structures', 'components/web-animations-js/web-animations.min'], function (Debug, Color, _, structures) { var months = ['January', 'February', 'March', 'April', 'Mai', 'June', 'July', 'August', 'September', 'October', 'November', 'December']; var days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']; function noop() { } var regQuote = /&quot;/g, regJpath = /^element\\./; const units = ['B', 'KiB', 'MiB', 'GiB', 'TiB']; function makejPathFunction(jpath) { // comment if (!jpath) { return noop; } var jpaths2 = jpath.replace(regJpath, ''), splitted = jpaths2.split('.'), l = splitted.length - 1, ifArray = [], ifString, ifElement = 'el'; for (var i = 0; i &lt; l; i++) { ifElement += '[&quot;' + splitted[i].replace(regQuote, '\\\\&quot;') + '&quot;]'; ifArray.push(ifElement + ' != undefined'); } ifString = ifArray.join(' &amp;&amp; '); if (!ifString) { ifString = 'true'; } var functionEvaled = noop; eval('functionEvaled = function( el ) { if (el &amp;&amp; ' + ifString + ') return ' + ifElement + '[&quot;' + splitted[l].replace(regQuote, '\\\\&quot;') + '&quot;]' + '; };'); return functionEvaled; } function getCSS(ruleName, deleteFlag) { ruleName = ruleName.toLowerCase(); if (!document.styleSheets) { return; } var i = 0, stylesheet, ii, cssRule; for (; i &lt; document.styleSheets.length; i++) { stylesheet = document.styleSheets[i]; ii = 0; cssRule = false; do { // For each rule in stylesheet cssRule = stylesheet.cssRules ? stylesheet.cssRules[ii] : (stylesheet.rules ? stylesheet.rules[ii] : null); if (!cssRule || !cssRule.selectorText) { ii++; continue; } if (cssRule.selectorText.toLowerCase() == ruleName) { if (deleteFlag) { if (stylesheet.cssRules) { stylesheet.deleteRule(ii); } else { stylesheet.removeRule(ii); } return true; } else { return cssRule; } } ii++; } while (cssRule); } return false; } var exports = { getCurrentLang: function () { return 'en'; }, maskIframes: function () { $('iframe').each(function () { var iframe = $(this); var pos = iframe.position(); var width = iframe.width(); var height = iframe.height(); iframe.before($('&lt;div /&gt;').css({ position: 'absolute', width: width, height: height, top: pos.top, left: pos.left, background: 'white', opacity: 0.5 }).addClass('iframemask')); }); }, unmaskIframes: function () { $('.iframemask').remove(); }, formatSize: function (size) { let i = 0; while (size &gt; 1024) { size = size / 1024; i++; } return `${Math.round(size * 100) / 100} ${units[i]}`; }, pad: function (val) { return val &lt; 10 ? '0' + val : val; }, getMonth: function (month) { return months[month]; }, getDay: function (day) { return days[day]; }, loadCss: function (url) { var that = this; return new Promise(function (resolve, reject) { url = require.toUrl(url); that.loadedCss = that.loadedCss || {}; if (that.loadedCss[url]) { // element is already loaded that.loadedCss[url].disabled = false; return resolve(that.loadedCss[url]); } var link = document.createElement('link'); link.type = 'text/css'; link.rel = 'stylesheet'; link.href = url; link.onload = function () { that.loadedCss[url] = link; resolve(link); }; try { document.getElementsByTagName('head')[0].appendChild(link); } catch (e) { reject(e); } }); }, unloadCss: function (url) { var that = this; url = require.toUrl(url); if (that.loadedCss[url]) { that.loadedCss[url].disabled = true; } }, getCssVendorPrefix: function () { var styles = window.getComputedStyle(document.documentElement, ''); var pre = (Array.prototype.slice .call(styles) .join('') .match(/-(moz|webkit|ms)-/) || (styles.OLink === '' &amp;&amp; ['', 'o']) )[1]; return '-' + pre + '-'; }, makejPathFunction: makejPathFunction, addjPathFunction: function (stack, jpath) { stack[jpath] = makejPathFunction(jpath); }, jpathToArray: function (val) { if (val) { var val2 = val.split('.'); val2.shift(); return val2; } else { return []; } }, jpathToString: function (val) { val = val || []; val = val.slice(); val.unshift('element'); return val.join('.'); }, getWebsafeFonts: function () { return [ {title: 'Arial', key: 'Arial'}, {title: 'Arial Black', key: 'Arial Black'}, {title: 'Comic Sans MS', key: 'Comic Sans MS'}, {title: 'Courier', key: 'Courier'}, {title: 'Courier new', key: 'Courier New'}, {title: 'Georgia', key: 'Georgia'}, {title: 'Helvetica', key: 'Helvetica'}, {title: 'Impact', key: 'Impact'}, {title: 'Palatino', key: 'Palatino'}, {title: 'Times new roman', key: 'Times New Roman'}, {title: 'Trebuchet MS', key: 'Trebuchet MS'}, {title: 'Verdana', key: 'Verdana'} ]; }, // CSS rules // Modified version // See http://www.hunlock.com/blogs/Totally_Pwn_CSS_with_Javascript // for original source getCSS: getCSS, removeCSS: function (ruleName) { return getCSS(ruleName, true); }, addCSS: function (ruleName) { if (!document.styleSheets) { return; } var rule; if (!(rule = getCSS(ruleName))) { if (document.styleSheets[0].addRule) { document.styleSheets[0].addRule(ruleName, null, 0); } else { document.styleSheets[0].insertRule(ruleName + ' { }', 0); } return getCSS(ruleName); } return rule; }, // http://stackoverflow.com/questions/9318674/javascript-number-currency-formatting formatMoney: function (n, decPlaces, thouSeparator, decSeparator) { decPlaces = isNaN(decPlaces = Math.abs(decPlaces)) ? 2 : decPlaces; decSeparator = decSeparator == undefined ? '.' : decSeparator; thouSeparator = thouSeparator == undefined ? ',' : thouSeparator; var sign = n &lt; 0 ? '-' : '', i = parseInt(n = Math.abs(+n || 0).toFixed(decPlaces)) + '', j = i.length; j = j &gt; 3 ? j % 3 : 0; return sign + (j ? i.substr(0, j) + thouSeparator : '') + i.substr(j).replace(/(\\d{3})(?=\\d)/g, '$1' + thouSeparator) + (decPlaces ? decSeparator + Math.abs(n - i).toFixed(decPlaces).slice(2) : ''); }, safeAccess: function () { var access = arguments[0]; for (var i = 1; i &lt; arguments.length; i++) { if (!(access = access[arguments[i]])) { return false; } } return access; } }; /** * No-op function */ exports.noop = function noop() { }; var uniqueid = 0; /** * Returns a unique id. * @param {boolean} [absolute] * @returns {string} */ exports.getNextUniqueId = function getNextUniqueId(absolute) { if (absolute) { return 'id_' + Date.now() + Math.round(Math.random() * 100000); } return 'uniqid_' + (++uniqueid); }; /** * Mark that a method should not be used. Returns a modified function which warns once when called. * @param {Function} method - the deprecated method * @param {string} [message] - optional message to log */ exports.deprecate = function deprecate(method, message) { var warned = false; return function deprecated() { if (!warned) { Debug.warn('Method ' + method.name + ' is deprecated. ' + (message || '')); warned = true; } return method.apply(this, arguments); }; }; /* TODO remove when Set API is supported in more browsers */ var warnOnceMap, warnOnceCheck; if (typeof Set === 'undefined') { warnOnceMap = {}; warnOnceCheck = function (name) { if (warnOnceMap[name]) { return true; } else { warnOnceMap[name] = true; return false; } }; } else { warnOnceMap = new Set(); warnOnceCheck = function (name) { if (warnOnceMap.has(name)) { return true; } else { warnOnceMap.add(name); return false; } }; } /** * Prints a warning message only once per id * @param id * @param message */ exports.warnOnce = function warnOnce(id, message) { if (!warnOnceCheck(id)) { Debug.warn(message); } }; /** * Make a constructor's prototype inherit another one, while adding optionally new methods to it. Also sets a `super_` * property to access the super constructor * @param {Function} ctor - New constructor * @param {Function} superCtor - Super constructor * @param {Object} [methods] - Methods to add to the new constructor */ exports.inherits = function (ctor, superCtor, methods) { ctor.super_ = superCtor; ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } }); if (methods) { _.assign(ctor.prototype, methods); } }; exports.getLoadingAnimation = function (size, color) { if (size === undefined) size = 32; if (color === undefined) color = 'black'; // Image taken from https://github.com/jxnblk/loading (loading-bars.svg) var $elem = $('\\ &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 32 32&quot; width=&quot;32&quot; height=&quot;32&quot; fill=&quot;black&quot;&gt;\\ &lt;rect x=&quot;0&quot; y=&quot;12&quot; width=&quot;4&quot; height=&quot;8&quot;&gt;&lt;/rect&gt;\\ &lt;rect x=&quot;7&quot; y=&quot;12&quot; width=&quot;4&quot; height=&quot;8&quot;&gt;&lt;/rect&gt;\\ &lt;rect x=&quot;14&quot; y=&quot;12&quot; width=&quot;4&quot; height=&quot;8&quot;&gt;&lt;/rect&gt;\\ &lt;rect x=&quot;21&quot; y=&quot;12&quot; width=&quot;4&quot; height=&quot;8&quot;&gt;&lt;/rect&gt;\\ &lt;rect x=&quot;28&quot; y=&quot;12&quot; width=&quot;4&quot; height=&quot;8&quot;&gt;&lt;/rect&gt;\\ &lt;/svg&gt;').attr({ width: size, height: size, fill: color }); var delay = 0; var duration = 1000; $elem.find('rect').each(function () { this.animate([ {transform: 'scale(1,1)'}, {transform: 'matrix(1,0,0,2,0,-16)'}, {transform: 'scale(1,1)'}, {transform: 'scale(1,1)'}, {transform: 'scale(1,1)'} ], { duration: duration, iterations: Infinity, delay: delay }); delay += duration / 6; }); return $elem; }; exports.moduleIdFromUrl = function (url) { var reg = /([^\\/]+)(\\/)?$/; var res = url.match(reg); return res[1]; }; exports.requireNeedsExtension = function (url) { return /^https?:\\/\\/|^\\.|^\\/|^\\/\\//.test(url); }; var utilReqPaths = {}; exports.rewriteRequirePath = function (url) { var rewrittenUrl = require.toUrl(url); if (!this.requireNeedsExtension(url)) { // return original url without trailing slash return url; } var reqPathStr = exports.getNextUniqueId(true); if (utilReqPaths[rewrittenUrl]) return utilReqPaths[url]; utilReqPaths[rewrittenUrl] = reqPathStr; var paths = {}; paths[reqPathStr] = rewrittenUrl; require.config({ paths: paths }); return reqPathStr; }; var objToString = Object.prototype.toString; exports.objectToString = function objectToString(obj) { return objToString.call(obj).slice(8, -1); }; exports.isArray = function isArray(arr) { return exports.objectToString(arr).slice('-5') === 'Array'; }; // Deprecated color methods. Moved to src/util/color exports.getDistinctColors = exports.deprecate(Color.getDistinctColors, 'use Color.getDistinctColors'); exports.getNextColorRGB = exports.deprecate(Color.getNextColorRGB, 'use Color.getNextColorRGB'); exports.hsl2rgb = exports.deprecate(Color.hsl2rgb, 'use Color.hsl2rgb'); exports.hueToRgb = exports.deprecate(Color.hue2rgb, 'use Color.hue2rgb'); exports.hexToRgb = exports.deprecate(Color.hex2rgb, 'use Color.hex2rgb'); exports.rgbToHex = exports.deprecate(Color.rgb2hex, 'use Color.rgb2hex'); exports.getColor = exports.deprecate(Color.getColor, 'use Color.getColor'); exports.evalOptions = function (options) { var result; if (!options) return undefined; if (!options.match(/^\\s*\\{/)) { options = '{' + options + '}'; } try { eval('result = ' + options); return result; } catch (e) { Debug.warn('could not eval options'); return undefined; } }; const isEmail = /^[-a-z0-9~!$%^&amp;*_=+}{\\'?]+(\\.[-a-z0-9~!$%^&amp;*_=+}{\\'?]+)*@([a-z0-9_][-a-z0-9_]*(\\.[-a-z0-9_]+)*\\.(aero|arpa|biz|com|coop|edu|gov|info|int|mil|museum|name|net|org|pro|travel|mobi|[a-z][a-z])|([0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}))(:[0-9]{1,5})?$/i; exports.isEmail = function (str) { return isEmail.test(str); }; // Taken from http://stackoverflow.com/questions/16245767/creating-a-blob-from-a-base64-string-in-javascript exports.b64toBlob = function (b64Data, contentType, sliceSize) { contentType = contentType || ''; sliceSize = sliceSize || 512; var byteCharacters = atob(b64Data); var byteArrays = []; for (var offset = 0; offset &lt; byteCharacters.length; offset += sliceSize) { var slice = byteCharacters.slice(offset, offset + sliceSize); var byteNumbers = new Array(slice.length); for (var i = 0; i &lt; slice.length; i++) { byteNumbers[i] = slice.charCodeAt(i); } var byteArray = new Uint8Array(byteNumbers); byteArrays.push(byteArray); } var blob = new Blob(byteArrays, {type: contentType}); return blob; }; exports.getStructuresComboOptions = function () { var typeList = []; typeList.push({key: '', title: 'none'}); var types = structures._getList(), l = types.length; for (var i = 0; i &lt; l; i++) { typeList.push({key: types[i], title: types[i]}); } return typeList; }; exports.contentTypeToType = function (contentType) { switch (contentType) { case 'image/gif': return 'gif'; case 'image/tif': case 'image/tiff': return 'tiff'; case 'image/jpg': case 'image/jpeg': return 'jpg'; case 'image/png': return 'png'; case 'image/svg': return 'svg'; case 'chemical/x-jcamp-dx': return 'jcamp'; case 'chemical/x-mdl-sdfile': return 'sdf'; case 'chemical/x-mdl-molfile': return 'mol2d'; case 'text/html': return 'html'; case 'text/plain': return 'string'; default: return null; } }; return exports; }); Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Modules Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "},"module-src_util_api.html":{"id":"module-src_util_api.html","title":"Module: src/util/api","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Module: src/util/api Main visualizer API Source: api.js, line 3 Members &lt;static&gt; executeAction Deprecated: Execute a global visualizer action. This is deprecated. Use API.doAction instead. Source: api.js, line 275 Methods &lt;static&gt; cache(name [, value]) Cache a value in memory or retrieve it. The value can be retrieved anywhere API is available Parameters: Name Type Argument Description name string Name of the cached value value * &lt;optional&gt; New value to set Source: api.js, line 285 Returns: The cached value or undefined if used as a setter Type * &lt;static&gt; createData(name, data [, filter]) Create new data and set a variable to it Parameters: Name Type Argument Description name string Name of the variable data * Data to set filter string &lt;optional&gt; Url of the filter to use with this variable Source: api.js, line 159 &lt;static&gt; doAction(name [, value]) Send an action to all modules and global action scripts Parameters: Name Type Argument Description name string Action name value * &lt;optional&gt; Action value Source: api.js, line 261 &lt;static&gt; existVariable(varName) Check if a variable is defined Parameters: Name Type Description varName string Name of the variable Source: api.js, line 128 Returns: Type boolean &lt;static&gt; getData(varName) Get the DataObject associated to a variable Parameters: Name Type Description varName string Name of the variable Source: api.js, line 188 Returns: DataObject or undefined Type * &lt;static&gt; getVariable(name) Get a variable by name Parameters: Name Type Description name string Name of the variable Source: api.js, line 178 Returns: Type Variable &lt;static&gt; loading(id [, message]) Set a loading message or change the value of an existing message Parameters: Name Type Argument Description id string ID of the message message string &lt;optional&gt; Message content (default: value of the ID) Source: api.js, line 218 &lt;static&gt; setHighlight(element, onOff) Change the state of a highlight Parameters: Name Type Description element object | array Object with a _highlight property or array of highlight IDs onOff boolean Source: api.js, line 197 &lt;static&gt; setVariable(name [, sourceVariable], jpath [, filter]) Set a variable using a jpath Parameters: Name Type Argument Description name string Name of the variable sourceVariable Variable &lt;optional&gt; Source variable. If set, the new variable will be created relative to its jpath jpath Array.&lt;string&gt; filter string &lt;optional&gt; Url of the filter to use with this variable Source: api.js, line 140 &lt;static&gt; stopLoading(id) Remove a loading message Parameters: Name Type Description id string ID of the message Source: api.js, line 243 Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "},"module-src_util_color.html":{"id":"module-src_util_color.html","title":"Module: src/util/color","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Module: src/util/color Color manipulation Source: color.js, line 3 Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "},"module-src_util_couchdbAttachments.html":{"id":"module-src_util_couchdbAttachments.html","title":"Module: src/util/couchdbAttachments","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Module: src/util/couchdbAttachments Source: couchdbAttachments.js, line 38 Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "},"module-src_util_ui.html":{"id":"module-src_util_ui.html","title":"Module: src/util/ui","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Module: src/util/ui Global ui methods Source: ui.js, line 3 Module: src/util/ui Global ui methods Source: uploadUi.js, line 3 Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "},"module-src_util_util.html":{"id":"module-src_util_util.html","title":"Module: src/util/util","body":" Visualizer Modules src/util/apisrc/util/colorsrc/util/couchdbAttachmentssrc/util/uisrc/util/util Module: src/util/util Global utility methods Source: util.js, line 3 Methods &lt;static&gt; deprecate(method [, message]) Mark that a method should not be used. Returns a modified function which warns once when called. Parameters: Name Type Argument Description method function the deprecated method message string &lt;optional&gt; optional message to log Source: util.js, line 306 &lt;static&gt; getNextUniqueId( [absolute]) Returns a unique id. Parameters: Name Type Argument Description absolute boolean &lt;optional&gt; Source: util.js, line 294 Returns: Type string &lt;static&gt; inherits(ctor, superCtor [, methods]) Make a constructor's prototype inherit another one, while adding optionally new methods to it. Also sets a super_property to access the super constructor Parameters: Name Type Argument Description ctor function New constructor superCtor function Super constructor methods Object &lt;optional&gt; Methods to add to the new constructor Source: util.js, line 361 &lt;static&gt; noop() No-op function Source: util.js, line 285 &lt;static&gt; warnOnce(id, message) Prints a warning message only once per id Parameters: Name Type Description id message Source: util.js, line 348 Ã— Search results Close Documentation generated by JSDoc 3.4.0 on Wed Jun 8th 2016 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
